---
layout: post
title: java-笔试-算法题，关联 面试
categories: [ dev ]
tags: []
---

* 参考
  * [Java实现八种常用排序算法，你会几个？](https://zhuanlan.zhihu.com/p/518613189)
  * []()
  * []()
  * []()
  * []()
  * []()
  * []()
  * []()
  * []()


## 查找算法

### 二分查找

#### 递归实现

~~~java
public class BinarySearchRecursive {

    public static void main(String[] args) {
        int[] arr = { 1, 2, 4, 6, 8, 9 };
        int key = 4;
        int result = recursionBinarySearch(arr, key, 0, arr.length-1);
        
        System.out.println("searching " + key + " index is :" + result);
    }
    
    public static int recursionBinarySearch(int[] data, int key, int low, int high) {
        if( key < data[low] || key > data[high] || low > high) {
            return -1;
        }
        
        int middle = (low + high) / 2;
        if( key < data[middle] ) {
            return recursionBinarySearch(data, key, low, middle - 1);
        }
        if( key > data[middle] ) {
            return recursionBinarySearch(data, key, middle + 1, high);
        }
        return middle;
    }

}
~~~

#### 不使用递归

~~~java
public class BinarySearchNoRecursion {

    public static void main(String[] args) {
        // TODO Auto-generated method stub

    }
    
    public static int commonBinarySearch(int[] arr, int key) {
        int low = 0;
        int high = arr.length - 1;
        int middle = 0;
        
        if( key < arr[low] || key > arr[high] || low > high ) {
            return -1;
        }
        
        while(low <= high) {
            middle = (low + high) / 2;
            if( arr[middle] > key ) {
                high = middle - 1;
            } else if ( arr[middle] < key ) {
                low = middle + 1;
            } else {
                return middle;
            }
        }
        
        return -1;
    }
}
~~~


### 插值查找算法

插值查找（Insert Value Search）是二分查找的一种改良，主要是改良了mid的值，mid的值由原来的`mid = (left + right) / 2`而变成了自适应获取mid的值`mid = left + (num - arr[left]) / (arr[right] - arr[left]) * (right - left)`，上述公式是前辈们推导出来的，其余和二分查找一样。

对于数据量较大，**关键字分布比较均匀**的查找表来说，采用插值查找，速度较快。而关键字分布不均匀的情况下，该方法不一定比二分查找要好。

~~~java
public static int insertValueSearch(int[] arr, int num) {
    return insertValueSearch(arr, 0, arr.length - 1, num);
}
 
public static int insertValueSearch(int[] arr, int left, int right, int num) {
    //如果没有找到
    if (left > right || num < arr[0] || num > arr[arr.length - 1]) {
        return -1;
    }
    //获取中间索引
    int mid = left + (num - arr[left]) / (arr[right] - arr[left]) * (right - left);
    //往左边递归找
    if (num < arr[mid]) {
        return insertValueSearch(arr, left, mid - 1, num);
    }
    //往右边递归找
    else if (num > arr[mid]) {
        return insertValueSearch(arr, mid + 1, right, num);
    }
    //数据位置找到
    else {
        return mid;
    }
}
~~~


### 斐波那契查找

黄金分割点查找：

黄金分割点查找要运用到斐波那契数列，要在该数列中从小到大找到一个数减一刚好大于等于待查找数组的长度，既顺序表长度n <= F[k] - 1
但顺序表长度 n 不一定刚好等于 F[k]-1，所以需要将原来的顺序表长度 n 增加至 F[k]-1（将最后一个字依次向后填充）。
这样一来带查找的顺序表就可以表示成：
由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到F[k]-1=（F[k-1]-1）+（F[k-2]-1）+1

黄金分割点的位置：mid = left + F(k - 1) - 1
注： 为什么是F[k] - 1,而不是F[k]?
因为斐波那契数列只有从第二个数开始与后一个数的比值才越来越接近黄金比率。
斐波那契数列的大小： 数组长度不同，那么对应所需要的斐波那契数列长度就不一样。若是写死，则很浪费空间。故斐波那契数列的大小可根据数组的大小进行选择。

当数组长度小于等于5时，数组的长度大于等于数组长度对应的斐波那契数，这时后面进行查找一个k使得fib[k]-1刚好大于等于数组长度就会越界，故写死，给一个6。产生的最大斐波那契数是8，大于数组长度，就不会越界
当数组长度大于5时，数组的长度小于数组长度对应的斐波那契数，斐波那契数组长度为待顺序表长度，不会产生越界


~~~java
public class FibonacciSearch {
    public static void main(String[] args) {
        int[] arr = {1,5,90,500,1000};
        FibonacciSearch fibonacciSearch = new FibonacciSearch();
        int i = fibonacciSearch.fibonacciSearch(arr, 1000);
        System.out.println("i = " + i);
    }

    /**
     * @Description: fibonacciSearch 斐波那契查找
     * @param: [arr, searchValue]
     * @return: int
     * @auther: zqq
     * @date: 20/6/18 10:18
     */
    public int fibonacciSearch(int[] arr, int searchValue){
        int left = 0;
        int right = arr.length - 1;
        int[] fib = fib(arr.length);
        int mid = 0;// 存储
        int k = 0;
        while (arr.length > fib[k] - 1){ // 找到一个k使得这个斐波那契数刚好大于等于right
            k++;
        }
        if (arr.length < fib[k]){
            arr = Arrays.copyOf(arr, fib[k]);// 因为right可能小于找到的斐波那契数，所以需要对数组扩容进行向后填充
            for (int i = right+1; i < arr.length; i++) {
                arr[i] = arr[right];
            }
        }
        while (left <= right){
            mid = left + fib[k - 1] - 1; // 分割点
            if (searchValue < arr[mid]){ // 在黄金分割点左边
                right = mid - 1;
                k--;// 向fib[k-1]的范围查找
            }else if (searchValue > arr[mid]){
                left = mid + 1;
                k -= 2;//向fib[k-2]的范围查找
            }else {
                if (mid <= right){
                    return mid;
                }else {
                    return right;
                }
            }
        }
        return -1;// 没有找到
    }

    /**
     * @Description: fib 构造斐波那契数列
     * @param: [right, left]
     * @return: int[]
     * @auther: zqq
     * @date: 20/6/18 9:50
     */
    public int[] fib( int right){
        int[] fibonacii;
        // 当数组长度小于等于5时，数组的长度大于等于数组长度对应的斐波那契数，
        // 这时后面进行查找一个k使得fib[k]-1刚好大于等于数组长度就会越界，故写死给一个6。产生的最大斐波那契数是8，大于数组长度，就不会越界
        if (right <= 5){
            fibonacii = new int[6];
        }else {//当数组长度大于5时，数组的长度小于数组长度对应的斐波那契数，不会产生越界
            fibonacii = new int[right];
        }

        fibonacii[0] = 1;
        fibonacii[1] = 1;
        for (int i = 2; i < fibonacii.length; i++) {
            fibonacii[i] = fibonacii[i -1] + fibonacii[i - 2];
        }
        return fibonacii;
    }
}
~~~





## 排序

### 冒泡排序

冒泡排序是一种简单的交换排序算法，以升序排序为例，其核心思想是：

从第一个元素开始，比较相邻的两个元素。如果第一个比第二个大，则进行交换。
轮到下一组相邻元素，执行同样的比较操作，再找下一组，直到没有相邻元素可比较为止，此时最后的元素应是最大的数。
除了每次排序得到的最后一个元素，对剩余元素重复以上步骤，直到没有任何一对元素需要比较为止。

~~~java
public void bubbleSortOpt(int[] arr) {

    if(arr == null) {
        throw new NullPoniterException();
    }
    if(arr.length < 2) {
        return;
    }
    int temp = 0;
    for(int i = 0; i < arr.length - 1; i++) {
        for(int j = 0; j < arr.length - i - 1; j++) {
            if(arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}
~~~


### 快速排序

快速排序的思想很简单，就是先把待排序的数组拆成左右两个区间，左边都比中间的基准数小，右边都比基准数大。接着左右两边各自再做同样的操作，完成后再拆分再继续，一直到各区间只有一个数为止。

~~~java
public void quickSort(int[] arr, int start, int end) {
    if(start < end) {
        // 把数组中的首位数字作为基准数
        int stard = arr[start];
        // 记录需要排序的下标
        int low = start;
        int high = end;
        // 循环找到比基准数大的数和比基准数小的数
        while(low < high) {
            // 右边的数字比基准数大
            while(low < high && arr[high] >= stard) {
                high--;
            }
            // 使用右边的数替换左边的数
            arr[low] = arr[high];
            // 左边的数字比基准数小
            while(low < high && arr[low] <= stard) {
                low++;
            }
            // 使用左边的数替换右边的数
            arr[high] = arr[low];
        }
        // 把标准值赋给下标重合的位置
        arr[low] = stard;
        // 处理所有小的数字
        quickSort(arr, start, low);
        // 处理所有大的数字
        quickSort(arr, low + 1, end);
    }
}
~~~


### 直接插入排序

~~~java
public void insertSort(int[] arr) {
    // 遍历所有数字
    for(int i = 1; i < arr.length - 1; i++) {
        // 当前数字比前一个数字小
        if(arr[i] < arr[i - 1]) {
            int j;
            // 把当前遍历的数字保存起来
            int temp = arr[i];
            for(j = i - 1; j >= 0 && arr[j] > temp; j--) {
                // 前一个数字赋给后一个数字
                arr[j + 1] = arr[j];
            }
            // 把临时变量赋给不满足条件的后一个元素
            arr[j + 1] = temp;
        }
    }
}
~~~


### 希尔排序

希尔排序把序列按下标的一定增量（步长）分组，对每组分别使用插入排序。随着增量（步长）减少，一直到一，算法结束，整个序列变为有序。因此希尔排序又称缩小增量排序。

~~~java
public void shellSort(int[] arr) {
    // gap 为步长，每次减为原来的一半。
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        // 对每一组都执行直接插入排序
        for (int i = 0 ;i < gap; i++) {
            // 对本组数据执行直接插入排序
            for (int j = i + gap; j < arr.length; j += gap) {
                // 如果 a[j] < a[j-gap]，则寻找 a[j] 位置，并将后面数据的位置都后移
                if (arr[j] < arr[j - gap]) {
                    int k;
                    int temp = arr[j];
                    for (k = j - gap; k >= 0 && arr[k] > temp; k -= gap) {
                        arr[k + gap] = arr[k];
                    }
                    arr[k + gap] = temp;
                }
            }
        }
    }
}
~~~













































































































































































































































