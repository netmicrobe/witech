---
layout: post
title: linux kvm 虚拟化
categories: [cm, linux]
tags: [kvm, qemu, cloud, libvirt]
---

* 参考： 
  * [厨师老六 - 云计算基础-管理KVM宿主服务器](https://www.jianshu.com/p/045c75437e2b)
  * [octetz.com - Linux Hypervisor Setup (libvirt/qemu/kvm)](https://octetz.com/docs/2020/2020-05-06-linux-hypervisor-setup/)
  * [Arch linux - wiki - QEMU](https://wiki.archlinux.org/title/QEMU_\(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87\))
  * []()
  * []()
  * []()
  * []()


## 入门： 安装环境、创建第一个虚拟机


1. 安装 qemu、libvirt和其他需要的组件

    ~~~
    pacman -Sy --needed \
      qemu \
      dhclient \
      openbsd-netcat \
      virt-viewer \
      libvirt \
      dnsmasq \
      dmidecode \
      ebtables \
      virt-install \
      virt-manager \
      bridge-utils
    ~~~

1. 调整执行权限

    方便 libvirt 的工具 default to `qemu:///system` ，否则缺省使用 `qemu:///session`

    ~~~
    sudo cp -rv /etc/libvirt/libvirt.conf ~/.config/libvirt/ &&\
    sudo chown ${YOURUSER}:${YOURGROUP} ~/.config/libvirt/libvirt.conf
    ~~~

    ~~~
    usermod -a -G polkit,wheel your-user-name
    ~~~

    edit `/etc/polkit-1/rules.d/50-libvirt.rules`

    ~~~
    /* Allow users in wheel group to manage the libvirt
    daemon without authentication */
    polkit.addRule(function(action, subject) {
        if (action.id == "org.libvirt.unix.manage" &&
            subject.isInGroup("wheel")) {
                return polkit.Result.YES;
        }
    });
    ~~~

    修改完，注销重新登陆， 或者重启 libvirtd


1. 配置、启动 libvirtd

    ~~~
    sudo systemctl start libvirtd
    sudo systemctl enable libvirtd
    ~~~

    libvirt keeps its files at `/var/lib/libvirt/`

    `images`目录是 VM磁盘镜像 的默认存放目录。


1. 创建一个虚拟机

    * 使用 `virt-manager` 图形界面创建
        1. 启动 `virt-manager` 出现GUI的管理界面。
        1. 点击 `Create a new virtual machine`
        1. 选择 `Local install media` ，添加新的 Storage Pool 到 存放iso的地方，选中需要的系统安装iso文件
        1. 设置系统的名称、CPU、内存、磁盘、网络（可以先选择 NAT）
        1. 点击 完成 后， virt-viewer 会弹出来现实安装进度。


    * 使用 `virt-install` 安装

        ~~~
        virt-install \
          --name ubuntu1804 \
          --ram 2048 \
          --disk path=/var/lib/libvirt/images/u19.qcow2,size=8 \
          --vcpus 2 \
          --os-type linux \
          --os-variant generic \
          --console pty,target_type=serial \
          --cdrom /var/lib/libvirt/isos/ubuntu-18.04.4-live-server-amd64.iso
        ~~~



## 虚拟机管理： 克隆、备份、恢复

### 查看所有虚拟机

~~~bash
virsh list --all
~~~


### Clone a VM

~~~bash
virt-clone \
  --original ubuntu18.04 \
  --name cloned-ubuntu \
  --file /var/lib/libvirt/images/cu.qcow2
~~~


### 虚拟机的block device 信息

~~~bash
virsh domblklist vm-name
~~~


### 查看虚拟机信息

~~~bash
virsh dominfo vm-name
~~~

### cdrom 操作

Eject : `virsh change-media $VMName --path sda --eject --live`
Insert : `virsh change-media $VMName --path sda --source $ISO --insert --live`




## 其他知识

* [qemu基本架构](https://blog.csdn.net/weixin_45774557/article/details/118574379)
* []()
* []()
* []()
* []()
* []()



在QEMU中`hypervisor: QEMU TCG`，Tiny Code Generator（TCG）将源处理器机器代码转换为虚拟机运行所需的机器代码块。

。在Tiny Code Generator（TCG）中，这些已经翻译的代码块放在转换缓存中，并通过跳转指令将源处理器的指令集（ISA）和目标处理器的指令集（ISA）链接在一起。

`TCG` and `KVM` are entirely separate modes of operation for QEMU. 

If you're using KVM (via -enable-kvm on the command line) then all guest instructions are either natively executed by the host CPU or (for a few instructions mostly doing I/O to emulated devices) emulated inside the host kernel

If you use QEMU in TCG mode (the default) then we are a pure emulator in userspace and make no use of the host CPU's hypervisor functionality. qemu-user-mode is always TCG emulation, and never KVM.




* 安装
安装 qemu，(或 qemu-headless，一个没有GUI的版本）并根据需要安装下面的可选软件包：

qemu-arch-extra - 额外架构支持
qemu-block-gluster - Glusterfs block 支持
qemu-block-iscsi - iSCSI block 支持
qemu-block-rbd - RBD block 支持
samba - SMB/CIFS 服务器支持

非官方的AUR包 `qemu-user-static` AUR 为所有QEMU支持的架构提供了一个带用户模式和静态链接模式的变种。它的预编译版本在这个包中: qemu-user-static-binAUR。 它的QEMU命令依照 qemu-target_architecture-static的规则命名, 例如, qemu-x86_64-static 代表目标架构为intel 64位CPU。

~~~
sudo pacman -S qemu qemu-arch-extra qemu-block-gluster qemu-block-iscsi qemu-block-rbd
sudo pacman -S samba
~~~

qemu 包提供了 x86_64 架构的模拟器， 可以进行全系统模拟 (`qemu-system-x86_64`)。 `qemu-arch-extra` 包提供了 x86_64 用户模式的模拟 (`qemu-x86_64`)。

* **全系统模拟模式 (full-system emulation)**

在该模式下, QEMU将会模拟一个完整的系统，包含一个或多个处理器以及各种外围设备。这种模式更加贴近真实的系统，且这种模式不要求被模拟的客户机系统是Linux，但它的速度较慢。

QEMU中启用full-system模式的命令依照如下规则进行命名 qemu-system-目标机器架构, 例如 qemu-system-x86_64 用于模拟64位intel架构CPU, qemu-system-i386 模拟32位intel架构CPU, qemu-system-arm 模拟ARM架构(32 位), qemu-system-aarch64 模拟ARM架构(64位), 等等。
如果模拟的CPU架构与宿主机的CPU架构相同, 那么即使在此模式下，QEMU仍有可能使用hypervisor(例如KVM or Xen)的技术对模拟机进行加速。

* **用户模式(Usermode emulation)**

在此模式下, QEMU能够利用宿主机的系统资源来调用为其他架构编译的Linux可执行文件



与其他的虚拟化程序如 VirtualBox 和 VMware 不同, QEMU不提供管理虚拟机的GUI（运行虚拟机时出现的窗口除外），也不提供创建具有已保存设置的持久虚拟机的方法。除非您已创建自定义脚本以启动虚拟机，否则必须在每次启动时在命令行上指定运行虚拟机的所有参数。

* 硬盘镜像

  * raw镜像
    和客户机器上看到的内容一模一样，并且将始终使用主机上的来宾硬盘驱动器的全部容量。此方法提供的I / O开销最小，但可能会浪费大量空间，因为guest虚拟机上未使用的空间无法在主机上使用。
  * qcow2 格式
    仅当客户系统实际写入内容的时候，才会分配镜像空间。对客户机器来说，硬盘大小表现为完整大小，即使它可能仅占用主机系统上的非常小的空间。此映像格式还支持QEMU快照功能

~~~bash
# 创建 raw 镜像文件，4G大小
# 用 dd 或 fallocate 也可以创建一个 raw 镜像。
qemu-img create -f raw image_file 4G

# 创建 qcow2 镜像文件，4G大小
qemu-img create -f qcow2 image_file 4G
~~~

创建上层镜像

~~~
qemu-img create -o backing_file=img1.raw,backing_fmt=raw -f qcow2 img1.cow

qemu-system-i386 img1.cow
~~~

调整镜像大小

~~~bash
# 适用于 raw 和 qcow2
# 在磁盘映像扩容后，必须使用虚拟机内部系统的分区工具对该镜像进行分区并格式化后才能真正开始使用新空间。 
# 在收缩磁盘映像时，必须首先使用虚拟机内部系统的分区工具减少分该分区的大小，然后相应地收缩磁盘映像，否则收缩磁盘映像将导致数据丢失！
qemu-img resize disk_image +10G
~~~

安装操作系统

~~~
qemu-system-x86_64 -cdrom iso文件路径 -boot order=d -m 4G -drive file=镜像文件路径,format=raw
~~~

可以用 `-boot menu=on` 代替 `-boot order=d` 启动boot菜单方便调试。

执行出错： `end Kernel panci - not syncing: System is deadlocked on memory`
默认情况下仅分配给虚拟机128MB的内存， 分配的内存大小可以通过 `-m` 调整， 比如 -m 512M 或 -m 2G

运行虚拟化的系统

~~~bash
qemu-system-i386 options disk_image
~~~

`Ctrl+Alt+g` 可以是否鼠标捕获。






