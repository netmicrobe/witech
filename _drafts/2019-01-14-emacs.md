---
layout: post
title: emacs 简单使用
categories: [ cm, emacs ]
tags: [editor]
---

* 参考
  * <https://emacs-doctor.com/>
  * <https://ccrma.stanford.edu/guides/package/emacs/emacs.html>
  * <https://blog.csdn.net/sparknow/article/details/39780683>
  * [Emacs China](https://emacs-china.org)
  * [Book - Emacs China](http://book.emacs-china.org/)



## 基本命令

* 说明
  * `C-x` 是 `Ctrl-x`，这里x是executing的意思。
    * `C-x C-h ` 列出所有可执行命令的帮助
  * `M-x`     命令名扩展。M-x 之后输入一个命令名。
    * 命令联想功能。在底部echo area 输入命令名称开头部分，按下 TAB 可以和shell自动补全命令。不用记住命令全称。
  

C-x C-c
: 保存并退出程序

C-x k
: 关闭当前buffer

C-g
: 取消命令。如果 Emacs 对你的命令失去响应，你可以很安全地用 `C-g` 来终止这个命令。 `C-g` 也可以被用来终止一个执行过久的命令。`C-g` 还可以被来取消数字参数和那些输入到一半的命令。

`C-x u` 或 `C-_`
: undo

C-x C-f
: find file

C-x C-s
: 储存当前文件

C-x s
: 保存多个缓冲区

C-x 0
: 关闭当前window

C-x 1
: 关闭其他window，只保留当前window

C-x C-left ， C-x left
: 跳转到前一个buffer

C-x C-right ，C-x right
: 跳转到后一个buffer

`M-x recover file<Return>`
: 恢复自动保存的文件。在提示确认的时候，输入 yes【回车】 就行了。 


C-SPACE 或 按住 SHIFT + 方向键
: 开始选择

C-a
: 移动到行首

C-e
: 移动到行尾

C-k
: 移除从光标到“行尾”间的字符

C-w
: 剪切

M-w
: 复制

C-y
: 粘帖

C-d
: 删除光标后的一个字符


### 基本的光标控制（BASIC CURSOR CONTROL）


~~~
                             上一行 C-p
                                  :
                                  :
            向左移 C-b .... 目前光标位置 .... 向右移 C-f
                                  :
                                  :
                             下一行 C-n
~~~


C-f
: 向右移动一个字符

C-b
: 向左移动一个字符

M-f
: 向右移动一个词【中文是移动到下一个标点符号】

M-b
: 向左移动一个词【中文是移动到上一个标点符号】

C-n
: 移动到下一行

C-p
: 移动到上一行

C-a
: 移动到行首， a 代表 ahead。

C-e
: 移动到行尾，e 代表 end。

M-a
: 移动到句首

M-e
: 移动到句尾

`M-<`
: （META 小于号）可以将光标移动到所有文字的最开头

`M->`
: （META 大于号）可以将光标移动到所有文字的最末尾。



### 搜索

C-s
: 是向前搜索。按下 C-s 之后，你会发现回显区里有“I-search”字样出现，这是在提示你目前 Emacs 正处于“渐进搜索”状态，正在等待你输入搜索字串。<Return> 会结束搜索。 

C-r
: 是向后搜索



### 编辑

#### 删除


* 被删除的内容会缓存到剪贴板，使用`C-y`可以粘帖出来。
* `C-k` 从当前位置删除到行尾，用的多。连续`C-k`的内容会在剪贴板合并，而不是后一次命令删除的内容覆盖前一次。



`<Delback>`
: 删除光标前的一个字符

C-d
: 删除光标后的一个字符

`M-<Delback>`
: 移除光标前的一个词

M-d
: 移除光标后的一个词

C-k
: 移除从光标到“行尾”间的字符

M-k
: 移除从光标到“句尾”间的字符


#### 粘帖

C-y
: 粘帖




#### 替换

M-x replace-string
: M-x replace-string 回车 要被替换的内容 回车 新的内容



### 连续重复操作

先输入 `C-u`，然后输入`数字`作为参数，最后再输入命令。

~~~
C-u 8 *，这将会插入 ********
~~~


### 复制、剪切、粘帖

1. `Ctrl-Space`
2. 鼠标选择 或者 键盘上箭头按键
3. `Alt-w`  拷贝 ， 或者， `Ctrl-w` 剪切
4. `Ctrl-y` 粘帖


#### `Ctrl-Space` 与输入法切换冲突的问题。

在`~/.emacs`文件中添加代码

~~~
;; C-SPACE 被输入法占用，C-@ 又太难按，于是把 set mark 绑定到 C-return
(define-key global-map [C-return] 'set-mark-command)
~~~



## 常用设置

### 配置文件

* Emacs 的配置文件默认保存在 `~/.emacs.d/init.el` 文件中。（如果其不存在可自行创建， 配置文件也可保存在 `~/.emacs` 文件中）
  * **注意**： 如果希望把配置放在 `~/.emacs.d/init.el` 文件中，那么需要手工删除 `~/.emacs` 文件。
* 在每次编辑配置文件后，刚刚做的修改并不会立刻生效。需要 **重启编辑器** 或者 **重新加载** 配置文件。
* 重新加载配置文件
  * 在当前配置文件中使用 `M-x load-file` 双击两次 回车确认默认文件名



### Major mode vs Minor mode

* Major Mode 通常是定义对于一种文件类型编辑的核心规则，例如语法高亮、缩进、快捷键绑定等。
* Minor Mode 是除去 Major Mode 所提供的核心功能以外的额外编辑功能（辅助功能）。例如`tool-bar-mode` 与 `linum-mode`。
* 一种文件类型同时只能存在一种 Major Mode 但是它可以同时激活一种或多 种 Minor Mode。
* 如果希望知道当前的模式信息，可以使用 `C-h m` 来显示当前所有开启 的全部 Minor Mode 的信息。
* 查看开启 的全部 Minor Mode ：`C-h m`
* 一般emacs自动选好mode，手动切换使用 `M-x` 加 `模式名称-mode`，例如，`M-x lisp-mode`。


* Major Modes
  1. Fundamental mode
  1. Normal Text or mark-up
      1. Text mode
      1. HTML mode
      1. SGML mode
      1. TeX mode
      1. Outline mode
  1. Programming Language
      1. Lisp mode
      1. C mode
  1. 与buffer用途有关的mode，不和具体文件相关
      1. Dired mode
      1. Message mode, `C-x m` 呼出
      1. Sehll mode



### 简单的编辑器自定义

需要做的就是将其写入你的配置文件中 （ ~/.emacs.d/init.el ）即可。

~~~
;; 关闭工具栏，tool-bar-mode 即为一个 Minor Mode
(tool-bar-mode -1)

;; 关闭文件滑动控件
(scroll-bar-mode -1)

;; 显示行号
(global-linum-mode 1)

;; 关闭启动帮助画面
(setq inhibit-splash-screen 1)

;; 更改显示字体大小 16pt
;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs
(set-face-attribute 'default nil :height 160)

;; 快速打开配置文件
(defun open-init-file()
  (interactive)
  (find-file "~/.emacs.d/init.el"))

;; 这一行代码，将函数 open-init-file 绑定到 <f2> 键上
(global-set-key (kbd "<f2>") 'open-init-file)
~~~





### 设置命令

`M-x auto fill mode<Return>`
: 启动或关闭自动折行模式。 Auto Fill 只在空白处进行断行。
  行边界通常被设定为 70 个字符【这里指英文字符】，用 `C-x f` 命令来重新设定之。
  指定新行边界可以用数字参数来进行传递。 
  如果你在段落的中间做了一些修改，那么自动折行模式不会替你把整个段落重新折行。
  重新自动折行用 `M-q`，注意使用的时候光标必须位于你想折行的那一段里。 

`M-x` 加 `模式名称-mode`
: 手动切换mode。 使用 `M-x` 加 `模式名称-mode`，例如，`M-x lisp-mode`。

M-x linum-mode
: 显示行号




### 插件管理

* 插件管理系统 可在菜单栏 Options -- Manage Emacs Packages 进入

#### Company 插件

* 安装
  * 使用默认的插件管理系统（可在菜单栏 Options > Manage Emacs Packages 中找到）安 装 Company 插件
* 用途
  * 一个用于代码补全的插件。
  * 它的名字代表补全一切的意思（ Comp lete Any thing）。
* 配置激活
  ~~~
  ; 开启全局 Company 补全
  (global-company-mode 1)
  ~~~






## Elisp 基础

* [X分钟速成elisp](https://learnxinyminutes.com/docs/zh-cn/elisp-cn/)
* [Common Lisp 里的一些基本概念](http://icodeit.org/2013/06/common-lisp-basic/)

`C-j`
: 计算当前光标到行首之间函数式结果，插入正文内容

`C-x C-e`
: 计算当前光标到行首之间函数式结果，显示在mini-buffer里。



Emacs Lisp 是一个函数式的语言。



### `*scratch*` buffer

* `C-x 方向键` 切换到 `*scratch*` buffer ， 可以在其中测试 elisp 语句。
* 这个buffer是 *lisp-interaction-mode*。
* 光标移动到函数式后，按下 `C-j` 或者 `C-x C-e`，就可以执行函数式计算。


### 基本写法，如何测试

~~~ lisp
(+ 3 (+ 1 2))
;;           ^ 光标放到这里
;; 按下`C-j' 就会输出 6
;; `C-j' 会在buffer中插入当前运算的结果
;; 而`C-xC-e' 则会在emacs最底部显示结果，也就是被称作"minibuffer"的区域
;; 为了避免把我们的buffer填满无用的结果，我们以后会一直用`C-x C-e'
~~~

### 变量

* `setq` 设置当前缓冲区（Buffer）中的变量值
* `setq-default` 设 置的为全局的变量的值

~~~ lisp
;; `setq' 可以将一个值赋给一个变量
(setq my-name "Bastien")
;; `C-x C-e' 输出 "Bastien" (在 mini-buffer 中显示)

;; 定义变量
(setq name "username")
(message name) ; -> "username"
~~~

### 列表

~~~
;; 我们将一些名字存到列表中：
(setq list-of-names '("Sarah" "Chloe" "Mathilde"))

;; 用 `car'来取得第一个名字：
(car list-of-names)

;; 用 `cdr'取得剩下的名字:
(cdr list-of-names)

;; 用 `push'把名字添加到列表的开头:
(push "Stephanie" list-of-names)

;; 注意: `car' 和 `cdr' 并不修改列表本身, 但是 `push' 却会对列表本身进行操作.
;; 这个区别是很重要的: 有些函数没有任何副作用（比如`car'）
;; 但还有一些却是有的 (比如 `push').
~~~

### mapcar

~~~
;; 我们来对`list-of-names'列表中的每一个元素都使用hello函数:
(mapcar 'hello list-of-names)

;; 将 `greeting' 改进，使的我们能够对`list-of-names'中的所有名字执行:
(defun greeting ()
    (switch-to-buffer-other-window "*test*")
    (erase-buffer)
    (mapcar 'hello list-of-names)
    (other-window 1))

(greeting)
~~~

### while 循环

~~~
(defun replace-hello-by-bonjour ()
    (switch-to-buffer-other-window "*test*")
    (goto-char (point-min))
    (while (search-forward "Hello")
      (replace-match "Bonjour"))
    (other-window 1))

;; (goto-char (point-min)) 将光标移到buffer的开始
;; (search-forward "Hello") 查找字符串"Hello"
;; (while x y) 当x返回某个值时执行y这个s式
;; 当x返回`nil' (空), 退出循环


(replace-hello-by-bonjour)

;; 你会看到所有在*test* buffer中出现的"Hello"字样都被换成了"Bonjour"

;; 你也会得到以下错误提示: "Search failed: Hello".
;;
;; 如果要避免这个错误, 你需要告诉 `search-forward' 这个命令是否在
;; buffer的某个地方停止查找, 并且在什么都没找到时是否应该不给出错误提示

;; (search-forward "Hello" nil t) 可以达到这个要求:

;; `nil' 参数的意思是 : 查找并不限于某个范围内
;; `t' 参数的意思是: 当什么都没找到时，不给出错误提示

~~~



### defun

~~~
;; 你可以把s式嵌入函数中
(defun hello () (insert "Hello, I am " my-name))
;; `C-xC-e' 输出 hello

;; 现在执行这个函数
(hello)
;; `C-xC-e' 输出 Hello, I am Bastien

;; 带参数的函数定义
(defun hello (name) (insert "Hello " name))
;; `C-xC-e' 输出 hello
(hello "you")
;; `C-xC-e' 输出 "Hello you"
~~~


### progn

~~~
;; 你可以用 `progn'命令将s式结合起来:
(progn
  (switch-to-buffer-other-window "*test*")
  (hello "you"))
;; `C-xC-e' 此时屏幕分为两个窗口，并且在*test* buffer中显示"Hello you"
~~~


### let

~~~
;; 你可以用 `let' 将一个值和一个局部变量绑定:
(let ((local-name "you"))
  (switch-to-buffer-other-window "*test*")
  (erase-buffer)
  (hello local-name)
  (other-window 1))

;; 我们再用`let'新建另一个函数:
(defun greeting (name)
  (let ((your-name "Bastien"))
    (insert (format "Hello %s!\n\nI am %s."
                    name       ; the argument of the function
                    your-name  ; the let-bound variable "Bastien"
                    ))))

;; 之后执行:
(greeting "you")
~~~


### 交互命令 read-from-minibuffer

~~~
;; 有些函数可以和用户交互:
(read-from-minibuffer "Enter your name: ")

;; 这个函数会返回在执行时用户输入的信息

;; 现在我们让`greeting'函数显示你的名字:
(defun greeting (from-name)
  (let ((your-name (read-from-minibuffer "Enter your name: ")))
    (insert (format "Hello!\n\nI am %s and you are %s."
                    from-name ; the argument of the function
                    your-name ; the let-bound var, entered at prompt
                    ))))

(greeting "Bastien")
~~~



### lisp 操作 emacs

#### switch-to-buffer-other-window

~~~
;; 下面我们在新的窗口中新建一个名为 "*test*" 的buffer:

(switch-to-buffer-other-window "*test*")
;; `C-xC-e' 这时屏幕上会显示两个窗口，而光标此时位于*test* buffer内

;; 用鼠标单击上面的buffer就会使光标移回。
;; 或者你可以使用 `C-xo' 使得光标跳到另一个窗口中
~~~

#### (goto-char (point-min)) 将光标移到buffer的开始

#### (search-forward "Hello") 查找字符串"Hello"

#### global-set-key 设置快捷键

~~~
;; 设置快捷键
(global-set-key (kbd "<f1>") 'func-name)
~~~


### 其他lisp语法

#### insert

~~~
;; `insert' 会在光标处插入字符串:
(insert "Hello!")
;; `C-xC-e' 输出 "Hello!"

(insert "Hello" " world!")
;; `C-xC-e' 输出 "Hello world!"

;; 你也可以用变量名来代替字符串
(insert "Hello, I am " my-name)
;; `C-xC-e' 输出 "Hello, I am Bastien"
~~~

#### format

~~~
;; 格式化字符串的方法：
(format "Hello %s!\n" "visitor")

(defun hello (name)
  (insert (format "Hello %s!\n" name)))
~~~



## 界面组成

![](emacs_screen_components.png)

### mode line

![](mode_line.png)

* 回车格式
  1. (Unix)
  2. (‘\’) or (DOS)
  3. (‘/’) or (Mac)

* 修改状态
  1. `--` 没有任何修改 
  1. `**` 被修改了
  1. `%%` 只读，且未修改 
  1. `%*` 只读，且已被修改 

* buffer 名称
  1. 名称两头都是星号，表示这个buffer不与文件关联，只是内存上的内容。














## emacs的常用命令

### buffer 控制

C-x C-b
: 列出所有buffers

C-x C-s
: 保存当前buffer

C-x k 或 M-x kill-buffer
: 关闭当前buffer

C-x b
: 跳转buffer，在底部mode line上下箭头切换buffer，回车后跳转

C-x C-left ， C-x left
: 跳转到前一个buffer

C-x C-right ，C-x right
: 跳转到后一个buffer


### windows 控制

C-x 0
: 关闭当前window

C-x 1
: 关闭其他window，只保留当前window

C-x 2
: 向下分解当前window

C-x 3
: 向右分解当前window

C-x `<`
: 向左滚动当前window

C-x `>`
: 向右滚动当前window

C-x `^`
: 放大窗口

C-x o
: 切换到其他窗口，类似Windows里面的ctrl-tab

### 外观

C-x C--
: 缩小字体

C-x C-+ ， C-x C-=
: 放大字体

C-x C-0
: 恢复字体标准大小


### debug

C-x \`
: 下一个错误



### 目录和文件

C-x C-d
: list-directory

C-x C-f
: find file

C-x C-s
: 储存当前文件

C-x s
: 保存多个缓冲区

C-x d
: dired

















## 帮助文档



C-h t
: 进入tutorial

C-h k
: 寻找快捷键的帮助信息

C-h v
: 寻找变量的帮助信息

C-h f
: 寻找函数的帮助信息

C-h i m elisp
: 阅读Emacs Lisp官方文档

--- ---

C-h i
: 返回上一次的位置

l
: 返回上一次的位置

n
: 下一个文档节点（同一个level），可能会略过当前节点的子节点

p
: 上一个文档节点（同一个level）

`]`
: 下一个文档节点，顺次向下遍历

`[`
: 上一个文档节点

u
: 上一级文档节点

空格
: 向下翻页

SHIFT + 空格 Backspace Del
: 向上翻页

`^`
: 当前文章节点的父章节

ENTER
: 跳转到链接目标


M-x customize
: 配置相关的帮助




## 问题

### 在Windows上emacs卡顿

将默认字体设置为 微软雅黑 ，就流畅了。

1. 菜单 Options - Set Default Fonts...
2. 菜单 Options - Save Options

参考： <https://emacs-china.org/t/topic/992/9>









